<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Arpeggio</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Scala and Arpeggio</h2>
					<h4>Audio processing with Scala Native and FS2</h4>
					<section>
						<img src="dist/images/pedalboard/all.jpg">
					</section>
				</section>
				<section>
					<h2>Meet the Team</h2>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/LLM.png">
					</section>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/polytune.png">
					</section>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/tumnus.png">
					</section>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/ACS1.png">
					</section>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/cloudburst.png">
					</section>
				</section>
				<section>
					<h2>Sound</h2>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/dry.png">
						</div>
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/sampled.png">
						</div>
					</section>
				</section>
				<section>
					<h2>A Direct Approach</h2>
					<section>
						<pre><code data-trim class="language-scala">
							def process(in: InputStream, out: OutputStream): Unit =
								val buffer: Array[Byte] = new Array[Byte](bufferSize)
								while true do
									val readBytes = in.read(buffer, 0, bufferSize)
									f(buffer) // transform the data in the buffer in some way
									out.write(buffer, 0, readBytes)
						</code></pre>
					</section>
				</section>
				<section>
					<h2>FS2</h2>
					<section><img src="dist/images/fs2-logo.png"></section>
					<section>
							<pre><code data-trim class="language-scala">
								Stream[F[_], Element]
							</code></pre>
							<pre class="fragment"><code data-trim class="language-scala">
								Chunk[Element]
							</code></pre>
							<pre class="fragment"><code data-trim class="language-scala">
								Pipe[F[_], Element, Element2] = Stream[F, Element] => Stream[F, Element2]
							</code></pre>
							<pre class="fragment"><code data-trim class="language-scala">
								trait AudioInterface[F[_]] {
									def input: Stream[F, Float]
									def output: Pipe[F, Float, Nothing]
								}

								type Pedal[F[_]] = Pipe[F, Float, Float]
							</code></pre>
				</section>
				</section>
				<section>
					<h4>Implementing an AudioInterface</h4>
					<section>
						<div>
							<div>
								<pre><code data-trim class="language-scala">
									def input: Stream[F, Float] =
										Pull
											.eval(F.blocking {
												val inputBuffer = new Array[Float](FRAMES_PER_BUFFER)
												functions.Pa_ReadStream(
													stream = pStream,
													buffer = inputBuffer.atUnsafe(0).toBytePointer,
													frames = FRAMES_PER_BUFFER.toULong
												)
												Chunk.ArraySlice(inputBuffer, 0, FRAMES_PER_BUFFER)
											})
											.flatMap(Pull.output)
											.streamNoScope
											.repeat
								</code></pre>
							</div>
							<div>
								<pre><code data-trim class="language-scala">
									def output: Pipe[F, Float, Nothing] =
										_.chunkN(FRAMES_PER_BUFFER).foreach { chunk =>
											val Chunk.ArraySlice(array, offset, length) =
												chunk.toArraySlice
											F.blocking {
												functions.Pa_WriteStream(
													stream = pStream,
													buffer = array.atUnsafe(offset).toBytePointer,
													frames = length.toULong
												)
												()
											}
										}
								</code></pre>
							</div>
						</div>
					</section>
					<section>
						<pre><code data-trim class="language-scala">
							package arpeggio
	
							import arpeggio.io.portaudio.PortAudioAudioInterface
							import cats.effect.{IO, IOApp}
	
							object Main extends IOApp.Simple:
								def run: IO[Unit] = PortAudioAudioInterface
									.resource[IO]
									.use(interface =>
										interface.input
											.through(somePedal)
											.through(someOtherPedal)
											.through(interface.output)
											.compile
											.drain
									)
						</code></pre>
					</section>
				</section>
				<section>
					<h4>Volume</h4>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/LLM.png">
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/dry.png">
						</div>
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/quiet.png">
						</div>
					</section>
					<section>
						<div>
							<pre><code data-trim class="language-scala">
								def adjustLevel[F[_]](gain: Float): Pedal[F] =
									_.map(_ * gain)
							</code></pre>
						</div>
						<div class="fragment">
							<pre><code data-trim class="language-scala">
								def sweep[F[_]](volumeControlStream: Stream[F, Float]): Pedal[F] =
									_.zipWith(volumeControlStream)(_ * _)
							</code></pre>
						</div>
					</section>
				</section>
				<section>
					<h4>Overdrive</h4>
					<section data-transition="fade">
						<img src="dist/images/pedalboard/tumnus.png">
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/dry.png">
						</div>
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/soft-clipping.png">
						</div>
					</section>
					<section data-transition="fade">
						<div class="graph">
							<img src="dist/images/charts/hard-clipping.png">
						</div>
					</section>
					<section>
						<pre><code data-trim class="language-scala">
							def symmetricHardClipping[F[_]](threshold: Float): Pedal[F] =
								_.map(sample =>
									Math.min(
										Math.max(sample, -threshold),
										threshold)
									)
						</code></pre>
					</section>
					<section>
						<img src="dist/images/pedalboard/tumnus.png">
					</section>
					<section>
						<img src="dist/images/klon-listing.png">
					</section>
					<section>
						<img src="dist/images/blended-overdrive.png">
					</section>
				</section>
				<section>
					<h4>Running pedals in parallel</h4>
					<section>
						<img src="dist/images/parallel-pedals.png">
					</section>
					<section data-auto-animate>
						<div class="fig-and-code">
							<img src="dist/images/parallel-pedals-join-highlighted.png" data-auto-animate-id="two">
							<div class="code-column">
								<pre><code data-trim class="language-scala">
									given pointwiseAdd[F[_]]: Semigroup[Stream[F, Float]] =
										new:
											def combine(
													x: Stream[F, Float],
													y: Stream[F, Float]
											): Stream[F, Float] =
												x.zipWith(y)(_ + _)
								</code></pre>
							</div>
						</div>
					</section>
					<section data-auto-animate>
						<div class="fig-and-code">
							<img src="dist/images/parallel-pedals-topic-highlighted.png" data-auto-animate-id="two">
							<div class="code-column">
								<pre><code data-trim class="language-scala">
									given pointwiseAdd[F[_]]: Semigroup[Stream[F, Float]] =
										new:
											def combine(
													x: Stream[F, Float],
													y: Stream[F, Float]
											): Stream[F, Float] =
												x.zipWith(y)(_ + _)
								</code></pre>
								<pre><code data-trim class="language-scala">
									def parallel[F[_]: Concurrent](
											pedal1: Pedal[F],
											pedal2: Pedal[F]
									): Pedal[F] = stream =>
										for {
											topic <- Stream.eval(UnthrottledChunkedTopic[F, Float])
											pedal1Output <-
												Stream.resource(topic.subscribeAwait.map(pedal1))
											pedal2Output <-
												Stream.resource(topic.subscribeAwait.map(pedal2))
											result <- (pedal1Output |+| pedal2Output)
												.concurrently(stream.through(topic.publish))
										} yield result
								</code></pre>
							</div>
						</div>
					</section>
					<section>
						<div class="fig-and-code">
							<img src="dist/images/blended-overdrive.png" data-auto-animate-id="two">
							<div class="code-column">
								<pre><code data-trim class="language-scala">
									def blended[F[_]: Concurrent](
											blend: Float,
											threshold: Float
									): Pedal[F] =
										parallel(
											adjustLevel(1 - blend),
											symmetricClipping(threshold) andThen adjustLevel(blend)
										)
								</code></pre>
							</div>
						</div>
					</section>
				</section>
				<section>
					<h2>Adding Guitar</h2>
					<section>
						<pre><code data-trim class="language-scala">
							package arpeggio

							import arpeggio.io.portaudio.PortAudioAudioInterface
							import cats.effect.{IO, IOApp}

							object Main extends IOApp.Simple:
								def run: IO[Unit] = PortAudioAudioInterface
									.resource[IO]
									.use(interface =>
										interface.input
											.through(pedals.overdrive.blended(blend = 0.8, threshold = 0.1))
											.through(interface.output)
											.compile
											.drain
									)
						</code></pre>
					</section>
				</section>
				<section>
					<h4>Reverb</h4>
					<section>
						<img src="dist/images/pedalboard/cloudburst.png">
					</section>
					<section>
						<img src="dist/images/schroeder/paper.png">
					</section>
					<section data-transition="none-out">
						<img src="dist/images/schroeder/reverberator.png">
					</section>
					<section data-transition="none-in">
						<img src="dist/images/schroeder/reverberator-boxed.png">
					</section>
					<section data-transition="none-out">
						<img src="dist/images/schroeder/delay.png">
					</section>
					<section data-transition="none-in">
						<img src="dist/images/schroeder/delay-line-boxed.png">
					</section>
					<section>
						<pre><code data-trim class="language-scala">
							def silence(time: Duration): Stream[Pure, Float] =
								val timeInFrames = time.toMicros * SAMPLE_RATE / 1000000
								Stream.constant(0f).take(timeInFrames.toLong)
						</code></pre>
						<pre><code data-trim class="language-scala">
							def delayLine[F[_]: Concurrent](time: Duration): Pedal[F] =
								silence(time) ++ _
						</code></pre>
					</section>
					<section>
						<div class="fig-and-code">
							<img src="dist/images/schroeder/comb-filter-topic-highlighted.png">
							<div class="code-container code-column">
								<pre><code data-trim class="language-scala">
									def echoStage[F[_]: Concurrent](
											repeatGain: Float,
											delayTime: Duration
									): Pedal[F] = stream =>
										for {
											topic <- Stream.eval(UnthrottledChunkedTopic[F, Float])
											outStream <- Stream.resource(topic.subscribeAwait)
											feedbackStream <- Stream.resource(
												topic.subscribeAwait.map(adjustLevel(repeatGain))
											)
											out <- outStream
												.concurrently(
													(stream |+| feedbackStream)
														.through(delayLine(delayTime))
														.through(topic.publish)
												)
										} yield out
								</code></pre>
							</div>
						</div>
					</section>
					<section>
						<img src="dist/images/schroeder/reverberator-boxed.png">
					</section>
					<section>
						<img src="dist/images/schroeder/all-pass.png">
					</section>
					<section>
						<div class="fig-and-code">
							<img src="dist/images/schroeder/all-pass-boxed.png">
							<div class="code-container code-column">
								<pre><code data-trim class="language-scala">
									def allPassStage[F[_]: Concurrent](
											repeatGain: Float,
											delayTime: Duration
									): Pedal[F] =
										parallel(
											adjustLevel(-repeatGain),
											echoStage(repeatGain, delayTime)
												.andThen(adjustLevel(1 - repeatGain * repeatGain))
										)
								</code></pre>
							</div>
						</div>
					</section>
					<section>
						<div class="fig-and-code">
							<img src="dist/images/schroeder/reverberator-boxed.png">
							<div class="code-column">
								<pre><code data-trim class="language-scala">
									def schroeder[F[_]: Concurrent](
											predelay: Duration,
											decay: Duration,
											mix: Float
									): Pedal[F] =
										parallel(
											identity,
											parallel(
												// Create 4 echo stages with differing delays and gain
												Seq(1f, 1.17f, 1.34f, 1.5f)
													.map(predelay * _)
													.map(t => echoRepeats(gain(decay, t), t)): _*
											)
											.andThen(allPassStage(0.7, 5.millis))
											.andThen(allPassStage(0.7, 1700.micros))
											.andThen(adjustLevel(mix))
										)
								</code></pre>
								<pre><code data-trim class="language-scala">
									def gain(decay: Duration, predelay: Duration): Float =
										Math.pow(2, (-3f * predelay.toMicros) / decay.toMicros).toFloat
								</code></pre>
							</div>
						</div>
					</section>
				</section>
				<section>
					<h2>Adding Guitar</h2>
					<section>
						<pre><code data-trim class="language-scala">
							package arpeggio

							import arpeggio.io.portaudio.PortAudioAudioInterface
							import arpeggio.pedals.reverb
							import cats.effect.{IO, IOApp}

							object Main extends IOApp.Simple:
								def run: IO[Unit] = PortAudioAudioInterface
									.resource[IO]
									.use(interface =>
										interface.input
											.through(
												reverb.schroeder(predelay = 30.millis, decay = 1.second, mix = 0.7)
											)
											.through(interface.output)
											.compile
											.drain
									)
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<div style="height:480px">
							<img src="dist/images/arpeggio-qr.png">
						</div>
						<h4 style="margin:2%">https://github.com/willbinzi/arpeggio</h4>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="dist/animation.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
